---
title: "Arrange links evenly along the sectors"
date: 2020-11-23
---

```{r, echo = FALSE}
library(knitr)
knitr::opts_chunk$set(
    error = FALSE,
    tidy  = FALSE,
    message = FALSE,
    warning = FALSE,
    fig.width = 5,
    fig.height = 5
)
library(GetoptLong)
options(digits = 4)
```

People use `circos.link()` to visualize interactions/relations between sectors.
When one sector has more than one other sectors to interact with, it actually
becomes important of how to arrange links on that sector to make every link readable.

In the following example, I created a random interaction data frame `df`:

```{r}
set.seed(123)
sectors = letters[1:20]
df = data.frame(from = sample(sectors, 40, replace = TRUE),
                to   = sample(sectors, 40, replace = TRUE))
df = unique(df)
df = df[df$from != df$to, ]
df
```

I also created the corresponding circular plot with all the sectors. In the
simplest way, we might want to put all the links to the center of every
sector, which looks like follows:

```{r}
library(circlize)
circos.initialize(sectors, xlim = c(0, 1))
circos.track(ylim = c(0, 1), panel.fun = function(x, y) {
    circos.text(CELL_META$xcenter, CELL_META$ycenter, CELL_META$sector.index)
})
for(i in seq_len(nrow(df))) {
    s1 = df[i, 1]
    s2 = df[i ,2]
    circos.link(s1, 0.5, s2, 0.5, directional = 1)
}
```

It looks nice, but since all the links, _e.g._ which start from or end in one
sector, are in a same position, it is rather difficult to tell which sector
has more links than the others.

To get rid of such link overlapping, we can assign random shift to every link
in the sector. In the following example, since the `xlim` for all sectors are
fixed in `c(0, 1)`, we use `runif(1)` to assign a random position between 0
and 1.

```{r}
circos.initialize(sectors, xlim = c(0, 1))
circos.track(ylim = c(0, 1), panel.fun = function(x, y) {
    circos.text(CELL_META$xcenter, CELL_META$ycenter, CELL_META$sector.index)
})
for(i in seq_len(nrow(df))) {
    s1 = df[i, 1]
    s2 = df[i ,2]
    circos.link(s1, runif(1), s2, runif(1), directional = 1)
}
```

It already looks much nicer, however, since the positions are random, it is 
still not easy to tell which sector has more links because we need effort to 
carefully count the links if they are very close to each other (_e.g._, for sector c,
are there four or five links?).

From **circlize** version 0.4.12.1001, I added a new function
`arrange_links_evenly()` which can arrange the links on the sectors so that
the neighouring distance between links are evenly distributed. It also adjusts
positions of links to make the overall intersection of linkes minimal.
Additionally, it considers directional links, _i.e._, on each sector, the
starting links and the ending links are put into separate groups.

```{r}
circos.initialize(sectors, xlim = c(0, 1))
circos.track(ylim = c(0, 1), panel.fun = function(x, y) {
    circos.text(CELL_META$xcenter, CELL_META$ycenter, CELL_META$sector.index)
})

df2 = arrange_links_evenly(df, directional = 1)

for(i in seq_len(nrow(df2))) {
    s1 = df$from[i]
    s2 = df$to[i]
    circos.link(df2[i, "sector1"], df2[i, "pos1"], 
                df2[i, "sector2"], df2[i, "pos2"],
                directional = 1)
}
```

Session info:

```{r}
sessionInfo()
```

